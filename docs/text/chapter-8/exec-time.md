# 実行時間

## 1. 再帰関数の実行

ここは演習を交えながら説明しよう。

::: tip 演習 1. フィボナッチ数

$a_n = a_{n-1} + a_{n-2} (n \geq 3)$
$a_1 = 1, a_2 = 1$
を満たす数列 $\{a_n\}$ を、フィボナッチ数列と呼ぶ。

フィボナッチ数の第$n$項を求める関数を、定義に沿って再帰関数によって実装し、 $a_{20}$ を求めよ。
:::

$a_{20} = 6765$ である。

::: spoiler コード解答

```cpp:line-numbers
#include <iostream>
using namespace std;

int fib(int n) {
    if (n==1 || n==2) return 1;
    return fib(n-1) + fib(n-2);
}

int main() {
    cout << fib(20) << endl;
}
```

:::

しかし、この関数を使って $a_{45}$ は求めようとすると実行にかなり時間がかかり、$a_{50}$ の計算は完了しなくなる。なぜだろうか？

::: tip 演習 2. フィボナッチ関数

演習 1. で実装した関数を「フィボナッチ関数」と呼ぶ。第$5$項を求める時に、フィボナッチ関数は総計で何回実行されるか。

:::

::: spoiler 解答

答えは 9 回である。

証明は数学的帰納法による。 $a_1, a_2$ は `fib` を1回実行する。以下、`fib` の実行回数を $f_n$ とする。  
`fib(3)` は `fib(2)` `fib(1)` を呼び出すが、それぞれの中で `fib` は呼ばれず、合計 $f_1, f_2$ 回呼び出される。
`fib(3)` を呼び出す回数も含めて、 $f_3 = f_2 + f_1 + 1 = 3$。  
同様に、 $f_4 = f_3 + f_2 + 1 = 5$。  
よって、 $f_5 = f_4 + f_3 + 1= 9$。
:::

この結果から、この関数で呼び出される `fib` の回数は、大体 $a_n$ 回くらいだと考えられる。

::: tip
この「大体」というのは少しむずかしい。

$n$が十分大きいとき `fib` が呼ばれる回数 $f_n$ と $a_n$ はおおよそ比例関係になる。
つまり、$n$ を正の無限大に飛ばしたときに、$\dfrac{f_n}{a_n}$ は正の有限値に収束する。
このとき、計算機科学的にはざっくり同じくらいの計算回数だと捉えられ、ここでは「大体」という言葉で説明される。

もし気になったのなら、「オーダー記法」「ランダウの記号」について調べると良い。余裕があれば第8章にて説明する。
:::

コンピューターは人間よりもずっと高速に計算できるが、無限に早く計算できる訳ではない。目安として、1秒に大体
$10^7$～$10^8$ 回の計算ができる。$a_{45}=1,134,903,170$ なので、大体10秒はかかる。$a_{50}$ に関しては更に時間がかかるだろう（おそらく5分ほど）。

「コンピューターは人間よりもずっと高速に計算できるが、無限に早く計算できる訳ではない」という事さえ頭の中に入れておけば、とりあえず問題ない。

## 2. 再帰関数の改善

このプログラムを TSUBAME に投げれば数秒で返ってくる**かも**しれない（実際はこのままだと返ってこないのだが…）。

しかし、そもそも自分の手で $a_5$ を計算する際に、足し算を9回も行っているだろうか？
実際は足し算は多くて5回ではないだろうか。
$a_{50}$ の計算も、たかだか50回の足し算さえすればよく、頑張れば5分以内に計算できる。  
こうなっては人間の方が計算速度が早いということになるが、冷静に考えてそんな訳はない。

ここで、自分たちが実際に行った計算方法を思い返して、それをプログラムに落とし込めば高速に計算できるのではないだろうか。

::: tip 演習 3. フィボナッチ関数の高速化

手計算での方法を思い出しながら、フィボナッチ数を計算するプログラムを実装し、$a_{45}=1,134,903,170$ を高速に（1秒以内に）計算せよ。

:::

:::spoiler ヒント 1

例えば $a_5$ は、 $a_4$ と $a_3$ の情報さえあれば計算できる。

:::

:::spoiler ヒント 2

for 文を使って、$a_1$ から順番に計算して、その計算結果を記憶すれば何度も計算せずに済む。

:::

:::spoiler ヒント 3

例えばフィボナッチ数列を記憶する変数 `vector<int> fibo` を用意してみたらどうだろうか。
for 文の中では何番目かを表す $i$ があるから、 $i-1$ 等すれば前のフィボナッチ数が取得できる。

:::

:::spoiler 解答コード

```cpp:line-numbers
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> fibo = {0, 1, 1};
    int n = 0;
    cin >> n;
    
    if (n <= 2) {
        cout << fibo[n];
        return 0;
    }
    
    for (int i=3; i<=n; i++) {
        int ai = fibo[i-1] + fibo[i-2];
        fibo.push_back(ai);
    }
    cout << fibo[n] << endl;
}
```

:::